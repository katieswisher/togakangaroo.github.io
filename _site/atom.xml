<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Feed Name</title>
  <link href="http://domain/"/>
  <link type="application/atom+xml" rel="self" href="http://domain/atom.xml"/>
  <updated>8/3/2014 10:09:40 PM</updated>
  <id>http://domain/</id>
  <author>
    <name>Author</name>
    <email>Email</email>
  </author>

  
  <entry>
    <id>http://domain//2014/08/02/be-the-javascriptiest.html</id>
    <link type="text/html" rel="alternate" href="http://domain//2014/08/02/be-the-javascriptiest.html"/>
    <title>Talk Roundup - Be the Javascriptiest</title>
    <updated>8/2/2014 12:00:00 AM</updated>
    <author>
      <name>Author</name>
      <uri>http://domain/</uri>
    </author>
    <content type="html"><h2>Be the Javascriptiest</h2>
<p>While there is some general philosophizing here, this is largely a step-by-step for building your own jquery collapsing widget. It is a writeup of my talk at <a href="http://sqlsaturday.com/324/eventhome.aspx">Sql Saturday #324 - Baton Rouge</a>. As such, it might seem lengthy and rambling. But the talk was over an hour so...</p>
<p>It all started as a joke, or rather as <a href="http://geekswithblogs.net/mikehuguet/Default.aspx">Mike Huguet</a> bugging me to submit something on javascript to which I responded with a flurry of serious submissions along with this silly, silly title. To nobody's surprise but my own, it of course got selected. I didn't know what to do with it. Oh well.</p>
<p>Fortunately I've got a lot to say. About Javascript especially.</p>
<p>But before I start, any time you want to talk javascript it's good to understand it's history as a baseline. Rather than rehashing the exact thing I said, <a href="https://www.w3.org/community/webed/wiki/A_Short_History_of_JavaScript">here's a series</a> of actually <a href="http://dailyjs.com/history-of-javascript.html">factual articles</a>. The general gist is this: <em>Brendan Eich was given ten days by Netscape to invent a browser language. He based it on Scheme. Marketing decided that it should look like Java, so it got some angle brackets.</em> The reason it is important to know this - there are parts of Javascript simply make no sense except in the historical context.</p>
<p>Another note. If you have not read this book. </p>
<p><img src="http://ecx.images-amazon.com/images/I/518QVtPWA7L._BO2,204,203,200_PIsitb-sticker-arrow-click,TopRight,35,-76_AA300_SH20_OU01_.jpg" alt="Javascript the Good Parts" /> </p>
<p>Read it. It's an easy read and covers most of the things you need to know. <a href="http://it-ebooks.info/book/274/">Hey, here it is for free.</a></p>
<p>So why this presentation at all? Well, despite the title. Javascript the Good Parts is mostly about the bad parts of Javascript. It's about all the stuff that was cludged into it by marketing, or all the mistakes that were made as a result of the insanely hurried timeframe, or all the things that have just staled over the last fifteen years of non-evolution.</p>
<p>But there are good parts. In my opinion here they are:</p>
<ul>
<li>Use functions for everything</li>
<li>Boolean Type Coercion</li>
<li>JSON Notation</li>
<li>Objects as hashes</li>
<li>Hoisting</li>
<li>Dynamic function signatures</li>
</ul>
<p>Rather than 30 slides about which I will blab for an hour I decided to do that thing that new presenters are always cautioned against - I decided to live-code. I decided to live-code a real life component that demonstrates why these things are awesome.</p>
<p>We're going to make a reusable collapser widget. This is what we're going for</p>
<p><a class="jsbin-embed" href="http://jsbin.com/zatey/5/embed?output">Final desired output</a></p>
<p>Click around. Nice, huh?</p>
<p>For simplicity's sake we're going to assume jquery. We're also going to start with the html and css already written because I'll assume you can get that knowledge elsewhere (and leave a comment if you would like another article on this).</p>
<p>Now let's consider our desired API. What we need is...a function. That will take an element. And make it collapsible. <code>makeCollapsible</code> sounds like a good function name for this, yeah?</p>
<pre><code class="javascript">
//Pass in jQuery
makeCollapsible( $('.should-collapse').first() );
//Pass in a DOM element
makeCollapsible( document.querySelector('.should-collapse') );
//Pass in an options object that overrides defaults
makeCollapsible( '.should-collapse', { 
  collapsed: true //should the initial state be collapsed?
} );
</code></pre>
<p>Good? Great.</p>
<p>Ok, let's get coding. So to start with <a href="http://en.wikipedia.org/wiki/Immediately-invoked_function_expression">let's create an IIFE</a>, create a stub function in the global scope, select some elements and invoke the stub on each.</p>
<pre><code class="javascript">
(function(){

  function makeCollapsible(el) {
    
  }
  
  window.makeCollapsible = makeCollapsible;
})()

////////////////////////////////////////////

$(function(){
  
  $('.should-collapse').toArray()
  		.map(function(el){ makeCollapsible(el) })
  
})
</code></pre>
<p>That looks nice, don't it? Straightforward. Keep in mind that if you need to export anything out of an IIFE you always want to do it at the very end. Also note that I call <code>toArray</code> on the jquery elements (called a matched set) and use the js array's built-in <code>.map</code>. This is because jquery - which preceeded the builtin map function - screwed up and inverted the parameters into the callback thereby making it harder to work with the 90% use case. Its almost entirely a matter of preference.</p>
<p>Ok, fun. Now let's get things actually working. First let's consider the html we want to achieve. If someone later uses javascript to remove the element entirely from the page we want it to remove cleanly, that means that everything has to go inside the element. We also want the triangle button to be visible when the element is collapsed - we therefore need it to be outside the area we will actually be collapsing. So what we're aiming for is something like this</p>
<pre><code class="html">
&lt;p class=&quot;should-collapse collapsible&quot;&gt;
    &lt;button class=&quot;collapsible-collapse-handle&quot; type=button&gt;&lt;/button&gt;
    &lt;span class=&quot;collapsible-collapse-area&quot;&gt;
        Text to collapse....
    &lt;/span&gt;
&lt;/p&gt;
</code></pre>
<p>We want to wrap the element contents in a new <code>&lt;span class=collapsible-collapse-area&gt;</code> and we want to prepend a new <code>&lt;button class=collapsible-collapse-handle&gt;</code>. And that's it. Our CSS will take care of the rest.</p>
<p>Creating this is helped tremendously by the existence of the jquery functions <a href="http://api.jquery.com/wrapinner/"><code>$.fn.wrapInner</code></a> and <a href="http://api.jquery.com/prependTo/"><code>$.fn.prependTo</code></a>, and the jquery api for <a href="http://api.jquery.com/jquery/#jQuery2">creating elements</a>.</p>
<pre><code class="javascript">
function makeCollapsible(el) {
	var $el = $(el);
	$el.addClass(&#039;collapsible&#039;);

	$el.wrapInner( $(&#039;&lt;span&gt;&#039;, {&#039;class&#039;: &#039;collapsible-collapse-area&#039;}) );
	var $collapseHandle = $(&#039;&lt;button&gt;&#039;, {&#039;class&#039;: &#039;collapsible-collapse-handle&#039;});
								.prependTo($el)
}
</code></pre>
<p>For those familiar with the above methods this should be fairly straightforward. </p>
<p>An additional thing to note is the <code>var $el = $(el)</code> rewrapping toward the top. </p>
<p>First on the <code>$name</code> convention - this is my convention for anything I know to be a jquery element. Usually I don't bother with <a href="http://en.wikipedia.org/wiki/Hungarian_notation">hungarian notation</a> but since you often use more than one jquery function on a single matched set it seems to make sense in this case.</p>
<p>Next on that re-wrapping. This is dynamic function signatures at work. You can pass anything into a jQuery function! It will just work. How do they achieve this? Why a large yet cleverly written if statement of course. There's no function overloading or pattern matching in javascript but who cares? <a href="https://github.com/jquery/jquery/blob/c869a1ef8a031342e817a2c063179a787ff57239/src/core/init.js#L16">It's not all that bad</a> and javascript benefits from a lower concept count. Don't get me wrong, I appreciate pattern matching and the like, its just that it frequently ends up being a nicer syntax for if statements. And there's a lot of rules and syntax to learn. It's definitely not a must-have language feature.</p>
<p>Now back to the problem at hand.</p>
<p>Perhaps we should make it actually work?</p>
<pre><code class="javascript">
function toggle(shouldShow) {
  $collapseHandle.next().toggle( !shouldShow );
  $el.toggleClass( 'collapsed', !shouldShow );
}

toggle(true);
</code></pre>
<p>So we first select the content area which we know to be the element that follows our $collapseHandler, and use <a href="http://api.jquery.com/toggle/"><code>$.fn.toggle</code></a> to hide or show it. And then we <a href="http://api.jquery.com/toggleClass/"><code>$.fn.toggleClass</code></a> to mark the element collapsed or not. Go ahead, try this out, change the <code>toggle(true)</code> below to <code>toggle(false)</code>.</p>
<p><a class="jsbin-embed" href="http://jsbin.com/weniqu/24/embed?js,output">Basic functionality</a></p>
<h3>Closure scoping</h3>
<p>I think this would have been confusing only three years ago but I feel like the concept of lambdas and closures is by now natural enough that most people aren't questioning why $collapseHandle and <code>$el</code> are available here. One thing that's nice about javascript functions, is they're dirt simple. Forget what you know about java or c# scoping, just scan up the levels of indentation - exactly what you would think should be available, is.</p>
<p>This might seem limiting - without private, protected, and internal modifiers it would seem we're pretty limited in our attempts at data hiding. As we will see, this is not true and this simple concept can yield largely the same results.</p>
<h3>Hoisting</h3>
<p>I took the opportunity for some cleanup. Javascript has this interesting concept called <a href="http://elegantcode.com/2010/12/24/basic-javascript-part-5-hoisting/">hoisting</a>. It can be dangerous but it has some interesting uses as well. It works something like this - the only thing that limits a variable's scope in javascript is being inside of a function; not for loops; not declaration order. This is implemented as follows.</p>
<p>When the javascript interpreter encounters a function it makes two passes. It first looks for any variable and function declarations in the immediate body and declares them. This is why can refer to variables in the same function before they are var'ed (even though the value might be undefined); </p>
<pre><code class="javscript">
console.log(foo); //error
(function(){
	console.log(foo); //undefined
	var foo = 5;
	console.log(foo); //5
})()
</code></pre>
<p>this can cause subtle bugs if you reuse a variable or function name in the same function, but it can also be used wisely. Here's the thing - function declarations (as opposed to assignments), can't be automatically split from their variable. So they are both declared <strong>and defined</strong> at the function top. This means that function declarations can appear <strong>anywhere</strong> within a function body and be used everywhere else, more to the point, it means that - much like in class-based languages, we can create many private helper methods am move them away from the code governing what the function actually does. </p>
<p>Since the details of what <code>toggle</code> does are far less important than what we're actually doing with it, I moved that code toward the bottom of my function. The specifics of how the html structure is imposed are similarly secondary to the fact that it happens, these also go in their own private function and are bumped to the bottom.</p>
<p><script src="http://static.jsbin.com/js/embed.js" async defer></script></p>
</content>
  </entry>
  
</feed>